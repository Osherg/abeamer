"use strict";
// uuid: ce496037-5728-4543-b2b1-f8a9aaa3d0f0

// ------------------------------------------------------------------------
// Copyright (c) 2018 Alexandre Bento Freire. All rights reserved.
// Licensed under the MIT License+uuid License. See License.txt for details
// ------------------------------------------------------------------------

// Implements a list of built-in chart Tasks

/** @module end-user | The lines bellow convey information for the end-user */

/**
 * ## Description
 *
 * A **chart task** task creates an animated chart.
 *
 * **WARN** This plugin is still in alpha stage, parts of API can change in the future.
 * It's still missing labelsX and legends and many internal parts.
 * It will be improved soon.
 *
 * This plugin has the following built-in charts:
 *
 * - `bar`.
 * - `line`.
 * - `area`.
 * - `mixed`- Draws different types of chars in the same chart, uses
 *   `chartTypes` parameter to determine the type of each chart per series.
 *
 * read the details on `AxisChartTaskParams`.
 */
namespace ABeamer {

  // #generate-group-section
  // ------------------------------------------------------------------------
  //                               Shape Tasks
  // ------------------------------------------------------------------------

  // The following section contains data for the end-user
  // generated by `gulp build-definition-files`
  // -------------------------------
  // #export-section-start: release

  export enum ChartTypes {
    bar,
    line,
    area,
    mixed,
  }

  export type ChartTaskName = 'chart';

  export type SeriesData = number[];


  export interface BaseChartTaskParams extends AnyParams {
    chartType?: ChartTypes | string;
    dataFrame: SeriesData[];
    animeSelector: string;
  }


  export interface AxisChartTaskParams extends BaseChartTaskParams {

    /** Chart Type per series. Use only if charType is `mixed`. */
    charTypes?: (ChartTypes | string)[];

    // labels X
    labelsX?: string[];
    labelsXHeight?: uint | ExprString;
    labelsXFontColor?: string | ExprString;
    labelsXFontFamily?: string | ExprString;
    labelsXFontSize?: uint | ExprString;

    // labels Y
    labelsY?: string[];
    labelsYWidth?: uint | ExprString;
    labelsYFontColor?: string | ExprString;
    labelsYFontFamily?: string | ExprString;
    labelsYFontSize?: uint | ExprString;

    // bar chart
    barWidth?: uint | ExprString;
    barMaxHeight?: uint | ExprString;
    barSpacing?: uint | ExprString;
    barSeriesSpacing?: uint | ExprString;
    barHeightStart?: number | ExprString;

    // colors
    fillColors?: string[];
    strokeColors?: string[];
    stokeWidth?: uint[];
    xAxisColor?: string | ExprString;
    yAxisColor?: string | ExprString;
    y0LineColor?: string | ExprString;

    // limits
    maxValue?: number | ExprString;
    minValue?: number | ExprString;
  }

  // #export-section-end: release
  // -------------------------------

  // ------------------------------------------------------------------------
  //                               Implementation
  // ------------------------------------------------------------------------

  pluginManager.addPlugin({
    id: 'abeamer.chart-tasks',
    uuid: '73631f28-df71-4b4d-88e1-c99a858e0fd3',
    author: 'Alexandre Bento Freire',
    email: 'abeamer@a-bentofreire.com',
    jsUrls: ['plugins/chart-tasks/chart-tasks.js'],
    teleportable: true,
  });


  function _parseSeriesList<T>(numSeries: int, list: T[],
    defaultValue: T, args: ABeamerArgs): T[] {

    const res = [];
    for (let i = 0; i < numSeries; i++) {
      if (list && i < list.length) {
        res.push(list[i]);
      } else {
        res.push(defaultValue);
      }
    }
    return res;
  }

  // ------------------------------------------------------------------------
  //                               _WkChart
  // ------------------------------------------------------------------------

  interface _WkChart {

    canvas: HTMLCanvasElement;
    context: CanvasRenderingContext2D;
    w: uint;
    h: uint;

    chartType: ChartTypes;
    min: number;
    max: number;
    seriesLen: uint;
    dataFrame: SeriesData[];

    animator: _ChartVirtualAnimator;
  }


  type _ChartFunc = (params: BaseChartTaskParams, out: _WkChart,
    stage: uint, args: ABeamerArgs) => void;

  // ------------------------------------------------------------------------
  //                               _ChartVirtualAnimator
  // ------------------------------------------------------------------------

  class _ChartVirtualAnimator implements VirtualAnimator {

    charts: _WkChart[] = [];
    params: BaseChartTaskParams;
    props: AnyParams = {};
    selector: string;
    chartFunc: _ChartFunc;


    getProp(name: PropName): PropValue {
      return this.props[name];
    }


    setProp(name: PropName, value: PropValue, args?: ABeamerArgs): void {
      this.props[name] = value;
      if (name !== 'uid') {
        this.charts.forEach(chart => {
          this.chartFunc(this.params, chart, TS_ANIME_LOOP, args);
        });
      }
    }
  }

  // ------------------------------------------------------------------------
  //                               Labels
  // ------------------------------------------------------------------------

  interface _Labels {
    values: string[];
    fontColor: string;
    fontFamily: string;
    fontSize: uint;
  }


  function _setUpLabelsFont(l: _Labels, ctx: CanvasRenderingContext2D): void {
    ctx.font = `${l.fontSize}px ${l.fontFamily}`;
    ctx.fillStyle = l.fontColor;
  }


  function _alignLabels(l: _Labels, ctx: CanvasRenderingContext2D,
    text: string, width: uint): uint {
    const sz = ctx.measureText(text);
    return (width - sz.width) / 2;
  }

  // ------------------------------------------------------------------------
  //                               Bar Chart
  // ------------------------------------------------------------------------

  interface _WkAxisChart extends _WkChart {

    /** Chart Type per series. Use only if charType is `mixed`. */
    chartTypes: ChartTypes[];

    // axis
    xAxisColor: string;
    yAxisColor: string;
    y0LineColor: string;

    // labels X
    labelsX: _Labels;
    labelsXHeight: uint;

    // labels Y
    labelsY: _Labels;
    labelsYWidth: uint;

    // bar chart
    barWidth: uint;
    barMaxHeight: uint;
    barSpacing: uint;
    barSeriesSpacing: uint;

    // colors
    fillColors: string[];
    stokeColors: string[];
    stokeWidth: uint[];

    // limits
    maxValue: number;
    minValue: number;
  }


  /** Initializes all the Axis Chart parameters. */
  function _initAxisChart(params: AxisChartTaskParams,
    chart: _WkAxisChart, args: ABeamerArgs): void {

    chart.chartTypes = chart.dataFrame.map((series, seriesIndex) => {
      if (chart.chartType !== ChartTypes.mixed) {
        return chart.chartType;
      }

      if (!params.charTypes || params.charTypes.length <= seriesIndex) {
        return ChartTypes.bar;
      }

      const chartType = params.charTypes[seriesIndex];
      return typeof chartType === 'string' ? ChartTypes[chartType] : chartType;
    });


    // axis
    chart.xAxisColor = ExprOrStrToStr(params.xAxisColor, 'black', args);
    chart.yAxisColor = ExprOrStrToStr(params.yAxisColor, 'black', args);
    chart.y0LineColor = ExprOrStrToStr(params.y0LineColor, 'black', args);

    // labels X
    chart.labelsXHeight = ExprOrNumToNum(params.labelsXHeight, 10, args);
    chart.labelsX = {
      values: params.labelsX,
      fontColor: ExprOrStrToStr(params.labelsXFontColor || params.labelsYFontColor, 'black', args),
      fontFamily: ExprOrStrToStr(params.labelsXFontFamily || params.labelsYFontFamily, 'sans-serif', args),
      fontSize: ExprOrNumToNum(params.labelsXFontSize || params.labelsXFontSize, 12, args),
    };

    // labels Y
    chart.labelsYWidth = ExprOrNumToNum(params.labelsYWidth, 20, args);
    chart.labelsY = {
      values: params.labelsY,
      fontColor: ExprOrStrToStr(params.labelsYFontColor || params.labelsXFontColor, 'black', args),
      fontFamily: ExprOrStrToStr(params.labelsYFontFamily || params.labelsXFontFamily, 'sans-serif', args),
      fontSize: ExprOrNumToNum(params.labelsYFontSize || params.labelsXFontSize, 12, args),
    };

    // bar chart
    chart.barWidth = ExprOrNumToNum(params.barWidth, 20, args);
    chart.barMaxHeight = ExprOrNumToNum(params.barMaxHeight, 100, args);
    chart.barSpacing = ExprOrNumToNum(params.barSpacing, 5, args);
    chart.barSeriesSpacing = ExprOrNumToNum(params.barSeriesSpacing, 0, args);

    const barHeightV = ExprOrNumToNum(params.barHeightStart, 0, args);
    chart.animator.props['bar-height'] = barHeightV;

    // limits
    chart.maxValue = ExprOrNumToNum(params.maxValue, chart.max, args);
    chart.minValue = ExprOrNumToNum(params.minValue, Math.min(chart.min, 0), args);

    // colors
    chart.fillColors = _parseSeriesList<string>(chart.dataFrame.length, params.fillColors,
      'white', args);
    chart.stokeColors = _parseSeriesList<string>(chart.dataFrame.length, params.strokeColors,
      'black', args);
    chart.stokeWidth = _parseSeriesList<uint>(chart.dataFrame.length, params.strokeWidth,
      1, args);
  }


  /** Implements Axis Chart animation. */
  function _axisChart(params: AxisChartTaskParams,
    chart: _WkAxisChart, stage: uint, args: ABeamerArgs): void {

    let barHeightV;

    switch (stage) {
      case TS_INIT:
        _initAxisChart(params, chart, args);
      case TS_ANIME_LOOP:
        barHeightV = chart.animator.props['bar-height'];
        break;
      default:
        return;
    }

    const w = chart.w;
    const h = chart.h;
    const ctx = chart.context;
    const x0 = chart.labelsYWidth;

    // bar
    const xbd = chart.barWidth;
    const xs = chart.barSpacing;
    const xss = chart.barSeriesSpacing;

    const labelsXHeight = chart.labelsXHeight;
    const y0 = h - labelsXHeight;
    const topMargin = 1;
    const yd = y0 - topMargin;
    const vM = chart.maxValue;
    const vm = chart.minValue;
    const vMd = vM - vm;

    const hasY0Line = vM * vm < 0;
    const vy0Line = hasY0Line ? 0 : vm >= 0 ? vm : vM;
    const vy0LineClip = (vy0Line - vm) / vMd;
    const axis0Y = y0 - yd * vy0LineClip;

    const dataFrame = chart.dataFrame;
    const seriesLen = chart.seriesLen;

    // computes x-shift created by side-by-side bars.
    // only bar charts cause a x-shift.
    const xShiftPerSeries = [];
    let xShift = 0;

    dataFrame.forEach((series, seriesI) => {
      if (chart.chartTypes[seriesI] === ChartTypes.bar) {
        if (xShift) {
          xShift += xss;
        }
        xShiftPerSeries.push(xShift);
        xShift += xbd;
      } else {
        xShiftPerSeries.push(0);
      }
    });
    if (!xShift) {
      xShift += xbd;
    }
    const dataFrameWidths = xShift + xs;
    // the last bar doesn't needs barSpacing
    const totalWidth = dataFrameWidths * seriesLen - xs;
    const x1 = x0 + totalWidth;

    ctx.clearRect(0, 0, w, h);

    const y = axis0Y;
    // data points
    dataFrame.forEach((series, seriesI) => {

      let xPrev: int;
      let yPrev: int;
      let points: int[][] = [];

      const chartType = chart.chartTypes[seriesI];
      ctx.lineWidth = chart.stokeWidth[seriesI];
      ctx.strokeStyle = chart.stokeColors[seriesI];
      ctx.fillStyle = chart.fillColors[seriesI];

      for (let i = 0; i < seriesLen; i++) {
        const x = x0 + dataFrameWidths * i + xShiftPerSeries[seriesI];
        const v = series[i];
        const vClip = (v - vy0Line) / vMd;
        const vT = vClip * barHeightV;
        const ybd = -yd * vT;
        const xbd2 = dataFrameWidths / 2;

        switch (chartType) {
          case ChartTypes.bar:
            ctx.fillRect(x, y, xbd, ybd);
            ctx.strokeRect(x, y, xbd, ybd);
            break;

          case ChartTypes.line:
            if (i) {
              ctx.moveTo(xPrev, yPrev);
              ctx.lineTo(x + xbd2, y + ybd);
              ctx.stroke();
            }
            xPrev = x + xbd2;
            yPrev = y + ybd;
            break;

          case ChartTypes.area:
            points.push([x + xbd2, y + ybd]);
            break;
        }
      }

      if (chartType === ChartTypes.area) {
        ctx.beginPath();
        ctx.moveTo(points[0][0], y);
        points.forEach(point => {
          ctx.lineTo(point[0], point[1]);
        });
        ctx.lineTo(points[points.length - 1][0], y);
        ctx.lineTo(points[0][0], y);
        ctx.fill();
        ctx.stroke();
      }
    });

    ctx.lineWidth = 1;

    // labels
    if (labelsXHeight && chart.labelsX.values) {
      for (let i = 0; i < seriesLen; i++) {
        const x = x0 + dataFrameWidths * i;
        const text = chart.labelsX.values[i];
        _setUpLabelsFont(chart.labelsX, ctx);
        const deltaX = _alignLabels(chart.labelsX, ctx, text, xShift);
        ctx.fillText(text, x + deltaX, y0 + labelsXHeight);
      }
    }

    // y0Line
    if (hasY0Line && chart.y0LineColor) {
      ctx.beginPath();
      ctx.strokeStyle = chart.y0LineColor;
      ctx.moveTo(x0, axis0Y);
      ctx.lineTo(x1, axis0Y);
      ctx.stroke();
    }

    // x-axis
    if (chart.xAxisColor) {
      ctx.beginPath();
      ctx.strokeStyle = chart.xAxisColor;
      ctx.moveTo(x0, y0);
      ctx.lineTo(x1, y0);
      ctx.stroke();
    }

    // y-axis
    if (chart.yAxisColor) {
      ctx.beginPath();
      ctx.strokeStyle = chart.yAxisColor;
      ctx.moveTo(x0, y0);
      ctx.lineTo(x0, y0 - yd);
      ctx.stroke();
    }
  }

  // ------------------------------------------------------------------------
  //                               Chart Task
  // ------------------------------------------------------------------------

  pluginManager.addTasks([['chart', _chartTask]]);


  /** Implements the Chart Task */
  function _chartTask(anime: Animation, wkTask: WorkTask,
    params: BaseChartTaskParams, stage: uint, args: ABeamerArgs): TaskResult {

    switch (stage) {
      case TS_INIT:
        let cType = params.chartType;
        if (typeof cType === 'string') {
          cType = ChartTypes[cType] as ChartTypes;
        }

        let chartFunc: _ChartFunc;

        switch (cType) {
          case ChartTypes.bar:
          case ChartTypes.line:
          case ChartTypes.area:
          case ChartTypes.mixed:
            chartFunc = _axisChart;
            break;
          default:
            throwI8n(Msgs.UnknownType, { p: params.chartType });
        }

        const dataFrame = params.dataFrame;
        if (!dataFrame.length) {
          throwErr(`Series have empty data`);
        }

        if (!params.animeSelector) {
          throwI8n(Msgs.NoEmptySelector, { p: `animeSelector` });
        }

        const animator = new _ChartVirtualAnimator();
        animator.selector = params.animeSelector;
        animator.chartFunc = chartFunc;
        animator.params = params;
        args.story.virtualAnimators.push(animator);

        const elAdapters = args.scene.getElementAdapters(anime.selector);
        args.vars.elCount = elAdapters.length;
        elAdapters.forEach((elAdapter, elIndex) => {

          args.vars.elIndex = elIndex;
          let max = -Number.MIN_VALUE;
          let min = Number.MAX_VALUE;
          const firstSeriesLen = dataFrame[0].length;
          dataFrame.forEach(series => {
            if (series.length !== firstSeriesLen) {
              throwErr(`Every Series must have the same length`);
            }
            series.forEach(point => {
              max = Math.max(max, point);
              min = Math.min(min, point);
            });
          });

          const canvas: HTMLCanvasElement = elAdapter.getProp('element', args) as any;
          const w = canvas.width;
          const h = canvas.height;

          if (!canvas) {
            throwErr(`Didn't find the ${elAdapter.getId()}`);
          }

          const chart: _WkChart = {
            canvas,
            context: canvas.getContext('2d'),
            w,
            h,

            chartType: cType as ChartTypes,
            min,
            max,
            seriesLen: firstSeriesLen,
            dataFrame,

            animator,
          };

          chartFunc(params, chart, stage, args);
          animator.charts.push(chart);
        });
        break;
    }
    return TR_EXIT;
  }
}
