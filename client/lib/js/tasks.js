"use strict";
// uuid: a54e855a-464d-4624-a7ce-fc39cb72a0f3
// ------------------------------------------------------------------------
// Copyright (c) 2018 Alexandre Bento Freire. All rights reserved.
// Licensed under the MIT License+uuid License. See License.txt for details
// ------------------------------------------------------------------------
// Implementation of Tasks
/** @module end-user | The lines bellow convey information for the end-user */
/**
 * ## Description
 *
 * A **task** is a function executed at the beginning of `addAnimations`,
 * before selector and properties information is processed,
 * and has the following goals:
 *
 * - *Setup*: A setup allows to prepare elements for further processing.
 *     An example is text splitting. text splitting prepares DOM for individual
 *     character manipulation.
 *     Setup tasks can stop the processing of a `addAnimations`, and might not
 *     require a selector..
 *
 * - *Wrapping*: Only `addAnimations` can be stored in a JSON file or sent
 *     for remote rendering. In this case, methods such as `addStills` and scene transitions
 *     need to be wrapped in a task.
 *     Wrapping tasks can stop the processing of a `addAnimations`, and might not
 *     require a selector.
 *
 * - *Asset creation*: A task can create an asset avoiding the need of loading external
 *     assets such as svg shape files.
 *
 * - *Complex animations*: A task can simplify the creation of a complex animation.
 *
 * ## Special Effects
 *
 * One of the important features in a batch animation is to produce special effects.
 * In ABeamer this is archive using tasks.
 *
 */
var ABeamer;
(function (ABeamer) {
    // #generate-group-section
    // ------------------------------------------------------------------------
    //                               Tasks
    // ------------------------------------------------------------------------
    // The following section contains data for the end-user
    // generated by `gulp build-definition-files`
    // -------------------------------
    // #export-section-start: release
    // ------------------------------------------------------------------------
    //                               Task Results
    // ------------------------------------------------------------------------
    ABeamer.TR_EXIT = 0;
    ABeamer.TR_DONE = 1;
    ABeamer.TR_INTERACTIVE = 2;
    // ------------------------------------------------------------------------
    //                               Task Stage
    // ------------------------------------------------------------------------
    ABeamer.TS_INIT = 0;
    ABeamer.TS_ANIME_LOOP = 1;
    ABeamer.TS_TELEPORT = 2;
    // #export-section-end: release
    // -------------------------------
    // ------------------------------------------------------------------------
    //                               Implementation
    // ------------------------------------------------------------------------
    /** Map of the built-in path tasks, plus the ones added via plugins. */
    ABeamer._taskFunctions = {};
    function _buildWorkTask(task, anime, toTeleport, args) {
        var handler = task.handler;
        var taskFunc;
        args.user = task.params;
        switch (typeof handler) {
            case 'string':
                taskFunc = ABeamer._taskFunctions[handler];
                break;
            case 'function':
                taskFunc = handler;
                ABeamer.throwIfI8n(toTeleport, ABeamer.Msgs.NoCode);
                break;
        }
        if (!taskFunc) {
            ABeamer.throwI8n(ABeamer.Msgs.UnknownOf, { type: ABeamer.Msgs.task, p: handler });
        }
        var wkTask = {
            func: taskFunc,
            name: handler,
            params: task.params || {},
            animeIndex: -1,
        };
        if (toTeleport) {
            task.handler = handler;
            taskFunc(anime, wkTask, wkTask.params, ABeamer.TS_TELEPORT, args);
        }
        return wkTask;
    }
    /**
     * Converts the Handlers into strings, and calls tasks on TELEPORT stage.
     */
    function _prepareTasksForTeleporting(anime, tasks, args) {
        tasks.forEach(function (task) { _buildWorkTask(task, anime, true, args); });
    }
    ABeamer._prepareTasksForTeleporting = _prepareTasksForTeleporting;
    /**
     * If it returns true, this Animation is full processed
     * and the animation should be bypassed.
     */
    function _processTasks(tasks, wkTasks, anime, args) {
        var toExit = true;
        tasks.forEach(function (task) {
            var wkTask = _buildWorkTask(task, anime, false, args);
            var taskResult = wkTask.func(anime, wkTask, wkTask.params, ABeamer.TS_INIT, args);
            switch (taskResult) {
                case ABeamer.TR_EXIT: return;
                case ABeamer.TR_DONE:
                    toExit = false;
                    break;
                case ABeamer.TR_INTERACTIVE:
                    toExit = false;
                    wkTasks.push(wkTask);
                    break;
            }
        });
        return toExit;
    }
    ABeamer._processTasks = _processTasks;
    function _runTasks(wkTasks, anime, animeIndex, args) {
        wkTasks.forEach(function (wkTask) {
            wkTask.animeIndex = animeIndex;
            wkTask.func(anime, wkTask, wkTask.params, ABeamer.TS_ANIME_LOOP, args);
        });
    }
    ABeamer._runTasks = _runTasks;
    // ------------------------------------------------------------------------
    //                               factory Task
    // ------------------------------------------------------------------------
    function _formatValue(value, isFormatted, index, args) {
        if (typeof value === 'object') {
            value = value[index % value.length];
        }
        if (!isFormatted) {
            return value;
        }
        var exprValue = ABeamer.ifExprCalc(value, args);
        return exprValue !== undefined ? exprValue.toString() :
            ABeamer.sprintf(value, index);
    }
    ABeamer._taskFunctions['factory'] = _factory;
    /** Implements the Factory Task */
    function _factory(anime, wkTask, params, stage, args) {
        switch (stage) {
            case ABeamer.TS_INIT:
                var tag_1 = params.tag || 'div';
                var count_1 = ABeamer.ifExprCalcNum(params.count, params.count, args);
                var needsClosing_1 = ['img'].indexOf(tag_1) === -1;
                var elAdapters = args.scene.getElementAdapters(anime.selector);
                elAdapters.forEach(function (elAdapter) {
                    var inTextHtml = [];
                    var _loop_1 = function (i) {
                        var parts = ['<' + tag_1];
                        (params.attrs || []).forEach(function (param) {
                            var value = _formatValue(param.value, param.isFormatted, i, args);
                            parts.push(" " + param.name + "=\"" + value + "\"");
                        });
                        parts.push('>');
                        parts.push(_formatValue(params.content || '', params.isContentFormatted, i, args));
                        if (needsClosing_1) {
                            parts.push("</" + tag_1 + ">");
                        }
                        inTextHtml.push(parts.join(''));
                    };
                    for (var i = 0; i < count_1; i++) {
                        _loop_1(i);
                    }
                    elAdapter.setProp('html', inTextHtml.join('\n'), args);
                });
                return ABeamer.TR_EXIT;
        }
    }
})(ABeamer || (ABeamer = {}));
//# sourceMappingURL=tasks.js.map