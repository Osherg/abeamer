"use strict";
// uuid: ce496037-5728-4543-b2b1-f8a9aaa3d0f0
// ------------------------------------------------------------------------
// Copyright (c) 2018 Alexandre Bento Freire. All rights reserved.
// Licensed under the MIT License+uuid License. See License.txt for details
// ------------------------------------------------------------------------
// Implements a list of built-in chart Tasks
/** @module end-user | The lines bellow convey information for the end-user */
/**
 * ## Description
 *
 * A **chart task** task creates an animated chart.
 *
 * **WARN** This plugin is still in alpha stage, parts of API can change in the future.
 * It's still missing labelsX and legends and many internal parts.
 * It will be improved soon.
 *
 * This plugin has the following built-in charts:
 *
 * - `bar`.
 * - `line`.
 * - `area`.
 * - `mixed`- Draws different types of chars in the same chart, uses
 *   `chartTypes` parameter to determine the type of each chart per series.
 *
 * read the details on `AxisChartTaskParams`.
 */
var ABeamer;
(function (ABeamer) {
    // #generate-group-section
    // ------------------------------------------------------------------------
    //                               Shape Tasks
    // ------------------------------------------------------------------------
    // The following section contains data for the end-user
    // generated by `gulp build-definition-files`
    // -------------------------------
    // #export-section-start: release
    var ChartTypes;
    (function (ChartTypes) {
        ChartTypes[ChartTypes["bar"] = 0] = "bar";
        ChartTypes[ChartTypes["line"] = 1] = "line";
        ChartTypes[ChartTypes["area"] = 2] = "area";
        ChartTypes[ChartTypes["mixed"] = 3] = "mixed";
    })(ChartTypes = ABeamer.ChartTypes || (ABeamer.ChartTypes = {}));
    // #export-section-end: release
    // -------------------------------
    // ------------------------------------------------------------------------
    //                               Implementation
    // ------------------------------------------------------------------------
    ABeamer.pluginManager.addPlugin({
        id: 'abeamer.chart-tasks',
        uuid: '73631f28-df71-4b4d-88e1-c99a858e0fd3',
        author: 'Alexandre Bento Freire',
        email: 'abeamer@a-bentofreire.com',
        jsUrls: ['plugins/chart-tasks/chart-tasks.js'],
        teleportable: true,
    });
    function _parseSeriesList(numSeries, list, defaultValue, args) {
        var res = [];
        for (var i = 0; i < numSeries; i++) {
            if (list && i < list.length) {
                res.push(list[i]);
            }
            else {
                res.push(defaultValue);
            }
        }
        return res;
    }
    // ------------------------------------------------------------------------
    //                               _ChartVirtualAnimator
    // ------------------------------------------------------------------------
    var _ChartVirtualAnimator = /** @class */ (function () {
        function _ChartVirtualAnimator() {
            this.charts = [];
            this.props = {};
        }
        _ChartVirtualAnimator.prototype.getProp = function (name) {
            return this.props[name];
        };
        _ChartVirtualAnimator.prototype.setProp = function (name, value, args) {
            var _this = this;
            this.props[name] = value;
            if (name !== 'uid') {
                this.charts.forEach(function (chart) {
                    _this.chartFunc(_this.params, chart, ABeamer.TS_ANIME_LOOP, args);
                });
            }
        };
        return _ChartVirtualAnimator;
    }());
    function _setUpLabelsFont(l, ctx) {
        ctx.font = l.fontSize + "px " + l.fontFamily;
        ctx.fillStyle = l.fontColor;
    }
    function _alignLabels(l, ctx, text, width) {
        var sz = ctx.measureText(text);
        return (width - sz.width) / 2;
    }
    /** Initializes all the Axis Chart parameters. */
    function _initAxisChart(params, chart, args) {
        chart.chartTypes = chart.dataFrame.map(function (series, seriesIndex) {
            if (chart.chartType !== ChartTypes.mixed) {
                return chart.chartType;
            }
            if (!params.charTypes || params.charTypes.length <= seriesIndex) {
                return ChartTypes.bar;
            }
            var chartType = params.charTypes[seriesIndex];
            return typeof chartType === 'string' ? ChartTypes[chartType] : chartType;
        });
        // axis
        chart.xAxisColor = ABeamer.ExprOrStrToStr(params.xAxisColor, 'black', args);
        chart.yAxisColor = ABeamer.ExprOrStrToStr(params.yAxisColor, 'black', args);
        chart.y0LineColor = ABeamer.ExprOrStrToStr(params.y0LineColor, 'black', args);
        // labels X
        chart.labelsXHeight = ABeamer.ExprOrNumToNum(params.labelsXHeight, 10, args);
        chart.labelsX = {
            values: params.labelsX,
            fontColor: ABeamer.ExprOrStrToStr(params.labelsXFontColor || params.labelsYFontColor, 'black', args),
            fontFamily: ABeamer.ExprOrStrToStr(params.labelsXFontFamily || params.labelsYFontFamily, 'sans-serif', args),
            fontSize: ABeamer.ExprOrNumToNum(params.labelsXFontSize || params.labelsXFontSize, 12, args),
        };
        // labels Y
        chart.labelsYWidth = ABeamer.ExprOrNumToNum(params.labelsYWidth, 20, args);
        chart.labelsY = {
            values: params.labelsY,
            fontColor: ABeamer.ExprOrStrToStr(params.labelsYFontColor || params.labelsXFontColor, 'black', args),
            fontFamily: ABeamer.ExprOrStrToStr(params.labelsYFontFamily || params.labelsXFontFamily, 'sans-serif', args),
            fontSize: ABeamer.ExprOrNumToNum(params.labelsYFontSize || params.labelsXFontSize, 12, args),
        };
        // bar chart
        chart.barWidth = ABeamer.ExprOrNumToNum(params.barWidth, 20, args);
        chart.barMaxHeight = ABeamer.ExprOrNumToNum(params.barMaxHeight, 100, args);
        chart.barSpacing = ABeamer.ExprOrNumToNum(params.barSpacing, 5, args);
        chart.barSeriesSpacing = ABeamer.ExprOrNumToNum(params.barSeriesSpacing, 0, args);
        var barHeightV = ABeamer.ExprOrNumToNum(params.barHeightStart, 0, args);
        chart.animator.props['bar-height'] = barHeightV;
        // limits
        chart.maxValue = ABeamer.ExprOrNumToNum(params.maxValue, chart.max, args);
        chart.minValue = ABeamer.ExprOrNumToNum(params.minValue, Math.min(chart.min, 0), args);
        // colors
        chart.fillColors = _parseSeriesList(chart.dataFrame.length, params.fillColors, 'white', args);
        chart.stokeColors = _parseSeriesList(chart.dataFrame.length, params.strokeColors, 'black', args);
        chart.stokeWidth = _parseSeriesList(chart.dataFrame.length, params.strokeWidth, 1, args);
    }
    /** Implements Axis Chart animation. */
    function _axisChart(params, chart, stage, args) {
        var barHeightV;
        switch (stage) {
            case ABeamer.TS_INIT:
                _initAxisChart(params, chart, args);
            case ABeamer.TS_ANIME_LOOP:
                barHeightV = chart.animator.props['bar-height'];
                break;
            default:
                return;
        }
        var w = chart.w;
        var h = chart.h;
        var ctx = chart.context;
        var x0 = chart.labelsYWidth;
        // bar
        var xbd = chart.barWidth;
        var xs = chart.barSpacing;
        var xss = chart.barSeriesSpacing;
        var labelsXHeight = chart.labelsXHeight;
        var y0 = h - labelsXHeight;
        var topMargin = 1;
        var yd = y0 - topMargin;
        var vM = chart.maxValue;
        var vm = chart.minValue;
        var vMd = vM - vm;
        var hasY0Line = vM * vm < 0;
        var vy0Line = hasY0Line ? 0 : vm >= 0 ? vm : vM;
        var vy0LineClip = (vy0Line - vm) / vMd;
        var axis0Y = y0 - yd * vy0LineClip;
        var dataFrame = chart.dataFrame;
        var seriesLen = chart.seriesLen;
        // computes x-shift created by side-by-side bars.
        // only bar charts cause a x-shift.
        var xShiftPerSeries = [];
        var xShift = 0;
        dataFrame.forEach(function (series, seriesI) {
            if (chart.chartTypes[seriesI] === ChartTypes.bar) {
                if (xShift) {
                    xShift += xss;
                }
                xShiftPerSeries.push(xShift);
                xShift += xbd;
            }
            else {
                xShiftPerSeries.push(0);
            }
        });
        if (!xShift) {
            xShift += xbd;
        }
        var dataFrameWidths = xShift + xs;
        // the last bar doesn't needs barSpacing
        var totalWidth = dataFrameWidths * seriesLen - xs;
        var x1 = x0 + totalWidth;
        ctx.clearRect(0, 0, w, h);
        var y = axis0Y;
        // data points
        dataFrame.forEach(function (series, seriesI) {
            var xPrev;
            var yPrev;
            var points = [];
            var chartType = chart.chartTypes[seriesI];
            ctx.lineWidth = chart.stokeWidth[seriesI];
            ctx.strokeStyle = chart.stokeColors[seriesI];
            ctx.fillStyle = chart.fillColors[seriesI];
            for (var i = 0; i < seriesLen; i++) {
                var x = x0 + dataFrameWidths * i + xShiftPerSeries[seriesI];
                var v = series[i];
                var vClip = (v - vy0Line) / vMd;
                var vT = vClip * barHeightV;
                var ybd = -yd * vT;
                var xbd2 = dataFrameWidths / 2;
                switch (chartType) {
                    case ChartTypes.bar:
                        ctx.fillRect(x, y, xbd, ybd);
                        ctx.strokeRect(x, y, xbd, ybd);
                        break;
                    case ChartTypes.line:
                        if (i) {
                            ctx.moveTo(xPrev, yPrev);
                            ctx.lineTo(x + xbd2, y + ybd);
                            ctx.stroke();
                        }
                        xPrev = x + xbd2;
                        yPrev = y + ybd;
                        break;
                    case ChartTypes.area:
                        points.push([x + xbd2, y + ybd]);
                        break;
                }
            }
            if (chartType === ChartTypes.area) {
                ctx.beginPath();
                ctx.moveTo(points[0][0], y);
                points.forEach(function (point) {
                    ctx.lineTo(point[0], point[1]);
                });
                ctx.lineTo(points[points.length - 1][0], y);
                ctx.lineTo(points[0][0], y);
                ctx.fill();
                ctx.stroke();
            }
        });
        ctx.lineWidth = 1;
        // labels
        if (labelsXHeight && chart.labelsX.values) {
            for (var i = 0; i < seriesLen; i++) {
                var x = x0 + dataFrameWidths * i;
                var text = chart.labelsX.values[i];
                _setUpLabelsFont(chart.labelsX, ctx);
                var deltaX = _alignLabels(chart.labelsX, ctx, text, xShift);
                ctx.fillText(text, x + deltaX, y0 + labelsXHeight);
            }
        }
        // y0Line
        if (hasY0Line && chart.y0LineColor) {
            ctx.beginPath();
            ctx.strokeStyle = chart.y0LineColor;
            ctx.moveTo(x0, axis0Y);
            ctx.lineTo(x1, axis0Y);
            ctx.stroke();
        }
        // x-axis
        if (chart.xAxisColor) {
            ctx.beginPath();
            ctx.strokeStyle = chart.xAxisColor;
            ctx.moveTo(x0, y0);
            ctx.lineTo(x1, y0);
            ctx.stroke();
        }
        // y-axis
        if (chart.yAxisColor) {
            ctx.beginPath();
            ctx.strokeStyle = chart.yAxisColor;
            ctx.moveTo(x0, y0);
            ctx.lineTo(x0, y0 - yd);
            ctx.stroke();
        }
    }
    // ------------------------------------------------------------------------
    //                               Chart Task
    // ------------------------------------------------------------------------
    ABeamer.pluginManager.addTasks([['chart', _chartTask]]);
    /** Implements the Chart Task */
    function _chartTask(anime, wkTask, params, stage, args) {
        switch (stage) {
            case ABeamer.TS_INIT:
                var cType_1 = params.chartType;
                if (typeof cType_1 === 'string') {
                    cType_1 = ChartTypes[cType_1];
                }
                var chartFunc_1;
                switch (cType_1) {
                    case ChartTypes.bar:
                    case ChartTypes.line:
                    case ChartTypes.area:
                    case ChartTypes.mixed:
                        chartFunc_1 = _axisChart;
                        break;
                    default:
                        ABeamer.throwI8n(ABeamer.Msgs.UnknownType, { p: params.chartType });
                }
                var dataFrame_1 = params.dataFrame;
                if (!dataFrame_1.length) {
                    ABeamer.throwErr("Series have empty data");
                }
                if (!params.animeSelector) {
                    ABeamer.throwI8n(ABeamer.Msgs.NoEmptySelector, { p: "animeSelector" });
                }
                var animator_1 = new _ChartVirtualAnimator();
                animator_1.selector = params.animeSelector;
                animator_1.chartFunc = chartFunc_1;
                animator_1.params = params;
                args.story.virtualAnimators.push(animator_1);
                var elAdapters = args.scene.getElementAdapters(anime.selector);
                args.vars.elCount = elAdapters.length;
                elAdapters.forEach(function (elAdapter, elIndex) {
                    args.vars.elIndex = elIndex;
                    var max = -Number.MIN_VALUE;
                    var min = Number.MAX_VALUE;
                    var firstSeriesLen = dataFrame_1[0].length;
                    dataFrame_1.forEach(function (series) {
                        if (series.length !== firstSeriesLen) {
                            ABeamer.throwErr("Every Series must have the same length");
                        }
                        series.forEach(function (point) {
                            max = Math.max(max, point);
                            min = Math.min(min, point);
                        });
                    });
                    var canvas = elAdapter.getProp('element', args);
                    var w = canvas.width;
                    var h = canvas.height;
                    if (!canvas) {
                        ABeamer.throwErr("Didn't find the " + elAdapter.getId());
                    }
                    var chart = {
                        canvas: canvas,
                        context: canvas.getContext('2d'),
                        w: w,
                        h: h,
                        chartType: cType_1,
                        min: min,
                        max: max,
                        seriesLen: firstSeriesLen,
                        dataFrame: dataFrame_1,
                        animator: animator_1,
                    };
                    chartFunc_1(params, chart, stage, args);
                    animator_1.charts.push(chart);
                });
                break;
        }
        return ABeamer.TR_EXIT;
    }
})(ABeamer || (ABeamer = {}));
//# sourceMappingURL=chart-tasks.js.map